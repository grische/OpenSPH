\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{classAlignedAllocator}{Aligned\+Allocator$<$ T $>$} }{\pageref{classAlignedAllocator}}{}
\item\contentsline{section}{\hyperlink{classArray}{Array$<$ T, T\+Counter $>$} }{\pageref{classArray}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1array__or__vector__selector}{Sph\+::array\+\_\+or\+\_\+vector\+\_\+selector$<$ D\+I\+M, T $>$} }{\pageref{structSph_1_1array__or__vector__selector}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1array__or__vector__selector_3-1_00_01T_01_4}{Sph\+::array\+\_\+or\+\_\+vector\+\_\+selector$<$-\/1, T $>$} }{\pageref{structSph_1_1array__or__vector__selector_3-1_00_01T_01_4}}{}
\item\contentsline{section}{\hyperlink{classArrayView}{Array\+View$<$ T, T\+Counter $>$} }{\pageref{classArrayView}}{}
\item\contentsline{section}{\hyperlink{structBaseType}{Base\+Type$<$ T\+Unit $>$} }{\pageref{structBaseType}}{}
\item\contentsline{section}{\hyperlink{classBasicIndices}{Basic\+Indices$<$ T $>$} }{\pageref{classBasicIndices}}{}
\item\contentsline{section}{\hyperlink{classBasicVector}{Basic\+Vector$<$ T $>$} }{\pageref{classBasicVector}}{}
\item\contentsline{section}{\hyperlink{classBasicVector_3_01double_01_4}{Basic\+Vector$<$ double $>$} }{\pageref{classBasicVector_3_01double_01_4}}{}
\item\contentsline{section}{\hyperlink{classBasicVector_3_01float_01_4}{Basic\+Vector$<$ float $>$} \\*3-\/dimensional vector, float precision }{\pageref{classBasicVector_3_01float_01_4}}{}
\item\contentsline{section}{\hyperlink{classBlockDomain}{Block\+Domain} }{\pageref{classBlockDomain}}{}
\item\contentsline{section}{\hyperlink{classBody}{Body} }{\pageref{classBody}}{}
\item\contentsline{section}{\hyperlink{classBoundingBox}{Bounding\+Box$<$ T, d $>$} }{\pageref{classBoundingBox}}{}
\item\contentsline{section}{\hyperlink{classBox}{Box} }{\pageref{classBox}}{}
\item\contentsline{section}{\hyperlink{classBruteForceFinder}{Brute\+Force\+Finder} \\*Search for neighbours by \textquotesingle{}brute force\textquotesingle{}, comparing every pair of vectors. Useful for testing other finders }{\pageref{classBruteForceFinder}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Callbacks}{Abstract\+::\+Callbacks} }{\pageref{classAbstract_1_1Callbacks}}{}
\item\contentsline{section}{\hyperlink{classSph_1_1CArray}{Sph\+::\+C\+Array$<$ T, N $>$} }{\pageref{classSph_1_1CArray}}{}
\item\contentsline{section}{\hyperlink{structChangePrecisionType}{Change\+Precision\+Type$<$ T, U $>$} \\*Change the base type of a quantity }{\pageref{structChangePrecisionType}}{}
\item\contentsline{section}{\hyperlink{structComponentIterator}{Component\+Iterator$<$ T\+Iterator $>$} }{\pageref{structComponentIterator}}{}
\item\contentsline{section}{\hyperlink{classConfigBlock}{Config\+Block} }{\pageref{classConfigBlock}}{}
\item\contentsline{section}{\hyperlink{classConfigValue}{Config\+Value} }{\pageref{classConfigValue}}{}
\item\contentsline{section}{\hyperlink{structConfigVisitor}{Config\+Visitor} }{\pageref{structConfigVisitor}}{}
\item\contentsline{section}{\hyperlink{structConstructType}{Construct\+Type$<$ n, T0, T\+Args $>$} \\*Constucts type given by runtime index }{\pageref{structConstructType}}{}
\item\contentsline{section}{\hyperlink{structConstructType_3_01n_00_01T0_01_4}{Construct\+Type$<$ n, T0 $>$} }{\pageref{structConstructType_3_01n_00_01T0_01_4}}{}
\item\contentsline{section}{\hyperlink{classCubicPacking}{Cubic\+Packing} \\*Cubic close packing }{\pageref{classCubicPacking}}{}
\item\contentsline{section}{\hyperlink{classCubicSpline}{Cubic\+Spline} \\*A cubic spline (M4) kernel }{\pageref{classCubicSpline}}{}
\item\contentsline{section}{\hyperlink{classDataFile}{Data\+File$<$ T\+Args $>$} }{\pageref{classDataFile}}{}
\item\contentsline{section}{\hyperlink{classDateFormat}{Date\+Format} }{\pageref{classDateFormat}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Distribution}{Abstract\+::\+Distribution} }{\pageref{classAbstract_1_1Distribution}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Domain}{Abstract\+::\+Domain} \\*Class for defining computational domain }{\pageref{classAbstract_1_1Domain}}{}
\item\contentsline{section}{\hyperlink{classDummyReferenceMaker}{Dummy\+Reference\+Maker$<$ T $>$} }{\pageref{classDummyReferenceMaker}}{}
\item\contentsline{section}{\hyperlink{structDummyTemplatedStruct}{Dummy\+Templated\+Struct$<$ T $>$} }{\pageref{structDummyTemplatedStruct}}{}
\item\contentsline{section}{\hyperlink{structEmptyFlags}{Empty\+Flags} }{\pageref{structEmptyFlags}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Eos}{Abstract\+::\+Eos} \\*Base class for equations of state }{\pageref{classAbstract_1_1Eos}}{}
\item\contentsline{section}{\hyperlink{structEps}{Eps$<$ T $>$} \\*Small value (compared with 1) for given precision }{\pageref{structEps}}{}
\item\contentsline{section}{\hyperlink{structEps_3_01double_01_4}{Eps$<$ double $>$} }{\pageref{structEps_3_01double_01_4}}{}
\item\contentsline{section}{\hyperlink{structEps_3_01float_01_4}{Eps$<$ float $>$} }{\pageref{structEps_3_01float_01_4}}{}
\item\contentsline{section}{\hyperlink{classEulerExplicit}{Euler\+Explicit} }{\pageref{classEulerExplicit}}{}
\item\contentsline{section}{\hyperlink{classFactory}{Factory} \\*Class providing construction of objects from enums. Contain only static member functions }{\pageref{classFactory}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Finder}{Abstract\+::\+Finder} }{\pageref{classAbstract_1_1Finder}}{}
\item\contentsline{section}{\hyperlink{classFlags}{Flags$<$ T\+Enum $>$} }{\pageref{classFlags}}{}
\item\contentsline{section}{\hyperlink{structForCurrentType}{For\+Current\+Type$<$ n, T0, T\+Args $>$} \\*Executes a functor with the current value (and current type) as a parameter }{\pageref{structForCurrentType}}{}
\item\contentsline{section}{\hyperlink{structForCurrentType_3_01n_00_01T0_01_4}{For\+Current\+Type$<$ n, T0 $>$} }{\pageref{structForCurrentType_3_01n_00_01T0_01_4}}{}
\item\contentsline{section}{\hyperlink{structforEachImpl}{for\+Each\+Impl$<$ i, n, T\+Functor, T\+Args $>$} }{\pageref{structforEachImpl}}{}
\item\contentsline{section}{\hyperlink{structforEachImpl_3_01n_00_01n_00_01TFunctor_00_01TArgs_8_8_8_01_4}{for\+Each\+Impl$<$ n, n, T\+Functor, T\+Args... $>$} }{\pageref{structforEachImpl_3_01n_00_01n_00_01TFunctor_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{structFunctionSignature}{Function\+Signature$<$ T\+Signature $>$} \\*Function traits }{\pageref{structFunctionSignature}}{}
\item\contentsline{section}{\hyperlink{structFunctionTraits}{Function\+Traits$<$ T\+Function $>$} }{\pageref{structFunctionTraits}}{}
\item\contentsline{section}{\hyperlink{structFunctionTraits_3_01TReturn_07_5_08_07TArgs_8_8_8_08_4}{Function\+Traits$<$ T\+Return($\ast$)(\+T\+Args...)$>$} }{\pageref{structFunctionTraits_3_01TReturn_07_5_08_07TArgs_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{structFunctionTraits_3_01TReturn_07TClass_1_1_5_08_07TArgs_8_8_8_08_01const_01_4}{Function\+Traits$<$ T\+Return(\+T\+Class\+::$\ast$)(\+T\+Args...) const $>$} }{\pageref{structFunctionTraits_3_01TReturn_07TClass_1_1_5_08_07TArgs_8_8_8_08_01const_01_4}}{}
\item\contentsline{section}{\hyperlink{structFunctionTraits_3_01TReturn_07TClass_1_1_5_08_07TArgs_8_8_8_08_4}{Function\+Traits$<$ T\+Return(\+T\+Class\+::$\ast$)(\+T\+Args...)$>$} }{\pageref{structFunctionTraits_3_01TReturn_07TClass_1_1_5_08_07TArgs_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{structGetMaxAlignmentType}{Get\+Max\+Alignment\+Type$<$ T\+Args $>$} }{\pageref{structGetMaxAlignmentType}}{}
\item\contentsline{section}{\hyperlink{structGetMaxSizeType}{Get\+Max\+Size\+Type$<$ T\+Args $>$} \\*Get a size of the largest type }{\pageref{structGetMaxSizeType}}{}
\item\contentsline{section}{\hyperlink{classGetTupleImplType}{Get\+Tuple\+Impl\+Type$<$ I, N, T0, T\+Args $>$} \\*A helper type extracting the type of the n-\/th element }{\pageref{classGetTupleImplType}}{}
\item\contentsline{section}{\hyperlink{classGetTupleImplType_3_01N_00_01N_00_01T0_00_01TArgs_8_8_8_01_4}{Get\+Tuple\+Impl\+Type$<$ N, N, T0, T\+Args... $>$} }{\pageref{classGetTupleImplType_3_01N_00_01N_00_01T0_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{classHaltonQrng}{Halton\+Qrng} }{\pageref{classHaltonQrng}}{}
\item\contentsline{section}{\hyperlink{structHaveProductType}{Have\+Product\+Type$<$ T1, T2, T\+Enabler $>$} \\*Can we get a product of T1 and T2? }{\pageref{structHaveProductType}}{}
\item\contentsline{section}{\hyperlink{structHaveQuotientType}{Have\+Quotient\+Type$<$ T1, T2, T\+Enabler $>$} \\*Can we get a quotient of T1 and T2? }{\pageref{structHaveQuotientType}}{}
\item\contentsline{section}{\hyperlink{classHexagonalPacking}{Hexagonal\+Packing} \\*Hexagonal close packing }{\pageref{classHexagonalPacking}}{}
\item\contentsline{section}{\hyperlink{classIdealGas}{Ideal\+Gas} \\*Equation of state for ideal gas }{\pageref{classIdealGas}}{}
\item\contentsline{section}{\hyperlink{structIgnore}{Ignore} \\*Placeholder for unused variables in }{\pageref{structIgnore}}{}
\item\contentsline{section}{\hyperlink{structIndexCast}{Index\+Cast$<$ T1, T2 $>$} }{\pageref{structIndexCast}}{}
\item\contentsline{section}{\hyperlink{structIndexCast_3_01T1_00_01T1_01_4}{Index\+Cast$<$ T1, T1 $>$} }{\pageref{structIndexCast_3_01T1_00_01T1_01_4}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1IndexDist__Sorter}{Sph\+::\+Index\+Dist\+\_\+\+Sorter} }{\pageref{structSph_1_1IndexDist__Sorter}}{}
\item\contentsline{section}{\hyperlink{classIntegrator}{Integrator$<$ T\+Rng, T\+Internal $>$} \\*\hyperlink{classObject}{Object} for integrating a generic scalar function }{\pageref{classIntegrator}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Interval}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+I\+M, Index\+Type $>$\+::\+Interval} }{\pageref{structSph_1_1KDTreeSingleIndexAdaptor_1_1Interval}}{}
\item\contentsline{section}{\hyperlink{structIsAngularType}{Is\+Angular\+Type$<$ T $>$} \\*Is angular unit (degrees or radians)? }{\pageref{structIsAngularType}}{}
\item\contentsline{section}{\hyperlink{structIsBaseAllType}{Is\+Base\+All\+Type$<$ T\+Base, T\+Args $>$} \\*A test if all types have the same common base T\+Base }{\pageref{structIsBaseAllType}}{}
\item\contentsline{section}{\hyperlink{structIsBaseAllType_3_01TBase_00_01T0_01_4}{Is\+Base\+All\+Type$<$ T\+Base, T0 $>$} }{\pageref{structIsBaseAllType_3_01TBase_00_01T0_01_4}}{}
\item\contentsline{section}{\hyperlink{structIsBaseAllType_3_01TBase_00_01T0_00_01TArgs_8_8_8_01_4}{Is\+Base\+All\+Type$<$ T\+Base, T0, T\+Args... $>$} }{\pageref{structIsBaseAllType_3_01TBase_00_01T0_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{structIsBaseType}{Is\+Base\+Type$<$ T, T\+Base, typename $>$} \\*A test if the the type T has a base T\+Base }{\pageref{structIsBaseType}}{}
\item\contentsline{section}{\hyperlink{structIsBaseType_3_01T_00_01TBase_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_01Base_3_01T_0c0a7ea670c56e23cbe6d6f78f2838e45}{Is\+Base\+Type$<$ T, T\+Base, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ Base$<$ T $>$, T\+Base $>$\+::value $>$ $>$} }{\pageref{structIsBaseType_3_01T_00_01TBase_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_01Base_3_01T_0c0a7ea670c56e23cbe6d6f78f2838e45}}{}
\item\contentsline{section}{\hyperlink{structIsDimensionlessType}{Is\+Dimensionless\+Type$<$ T $>$} \\*Is dimensionless? }{\pageref{structIsDimensionlessType}}{}
\item\contentsline{section}{\hyperlink{structIsPowerType}{Is\+Power\+Type$<$ T, n $>$} \\*Is the type a n-\/th power? }{\pageref{structIsPowerType}}{}
\item\contentsline{section}{\hyperlink{structIsValueOfPrecisionType}{Is\+Value\+Of\+Precision\+Type$<$ T, T\+Precision $>$} }{\pageref{structIsValueOfPrecisionType}}{}
\item\contentsline{section}{\hyperlink{structIsValueOfPrecisionType_3_01double_00_01double_01_4}{Is\+Value\+Of\+Precision\+Type$<$ double, double $>$} }{\pageref{structIsValueOfPrecisionType_3_01double_00_01double_01_4}}{}
\item\contentsline{section}{\hyperlink{structIsValueOfPrecisionType_3_01float_00_01float_01_4}{Is\+Value\+Of\+Precision\+Type$<$ float, float $>$} }{\pageref{structIsValueOfPrecisionType_3_01float_00_01float_01_4}}{}
\item\contentsline{section}{\hyperlink{structIsValueType}{Is\+Value\+Type$<$ T $>$} }{\pageref{structIsValueType}}{}
\item\contentsline{section}{\hyperlink{structIsValueType_3_01double_01_4}{Is\+Value\+Type$<$ double $>$} }{\pageref{structIsValueType_3_01double_01_4}}{}
\item\contentsline{section}{\hyperlink{structIsValueType_3_01float_01_4}{Is\+Value\+Type$<$ float $>$} }{\pageref{structIsValueType_3_01float_01_4}}{}
\item\contentsline{section}{\hyperlink{structIsVectorType}{Is\+Vector\+Type$<$ T $>$} \\*Helper type trait to determine if the type is a vector of some kind }{\pageref{structIsVectorType}}{}
\item\contentsline{section}{\hyperlink{structIsVectorType_3_01BasicVector_3_01T_01_4_01_4}{Is\+Vector\+Type$<$ Basic\+Vector$<$ T $>$ $>$} }{\pageref{structIsVectorType_3_01BasicVector_3_01T_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{classIterator}{Iterator$<$ T, T\+Counter $>$} }{\pageref{classIterator}}{}
\item\contentsline{section}{\hyperlink{classKdTree}{Kd\+Tree} }{\pageref{classKdTree}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1KDTreeEigenMatrixAdaptor}{Sph\+::\+K\+D\+Tree\+Eigen\+Matrix\+Adaptor$<$ Matrix\+Type, D\+I\+M, Distance $>$} }{\pageref{structSph_1_1KDTreeEigenMatrixAdaptor}}{}
\item\contentsline{section}{\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+I\+M, Index\+Type $>$} }{\pageref{classSph_1_1KDTreeSingleIndexAdaptor}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1KDTreeSingleIndexAdaptorParams}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor\+Params} }{\pageref{structSph_1_1KDTreeSingleIndexAdaptorParams}}{}
\item\contentsline{section}{\hyperlink{classKernel}{Kernel$<$ T\+Derived $>$} }{\pageref{classKernel}}{}
\item\contentsline{section}{\hyperlink{classSph_1_1KNNResultSet}{Sph\+::\+K\+N\+N\+Result\+Set$<$ Distance\+Type, Index\+Type, Count\+Type $>$} }{\pageref{classSph_1_1KNNResultSet}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1L1__Adaptor}{Sph\+::\+L1\+\_\+\+Adaptor$<$ T, Data\+Source, \+\_\+\+Distance\+Type $>$} }{\pageref{structSph_1_1L1__Adaptor}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1L2__Adaptor}{Sph\+::\+L2\+\_\+\+Adaptor$<$ T, Data\+Source, \+\_\+\+Distance\+Type $>$} }{\pageref{structSph_1_1L2__Adaptor}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1L2__Simple__Adaptor}{Sph\+::\+L2\+\_\+\+Simple\+\_\+\+Adaptor$<$ T, Data\+Source, \+\_\+\+Distance\+Type $>$} }{\pageref{structSph_1_1L2__Simple__Adaptor}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Logger}{Abstract\+::\+Logger} }{\pageref{classAbstract_1_1Logger}}{}
\item\contentsline{section}{\hyperlink{classLutKernel}{Lut\+Kernel} \\*A look-\/up table approximation of the kernel. Can be constructed from any S\+PH kernel }{\pageref{classLutKernel}}{}
\item\contentsline{section}{\hyperlink{classMatrix}{Matrix} }{\pageref{classMatrix}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1metric__L1}{Sph\+::metric\+\_\+\+L1} }{\pageref{structSph_1_1metric__L1}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1metric__L2}{Sph\+::metric\+\_\+\+L2} }{\pageref{structSph_1_1metric__L2}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1metric__L2__Simple}{Sph\+::metric\+\_\+\+L2\+\_\+\+Simple} }{\pageref{structSph_1_1metric__L2__Simple}}{}
\item\contentsline{section}{\hyperlink{classMultiLogger}{Multi\+Logger} \\*Class holding multiple loggers and writing messages to all of them. The objects is the owner of loggers }{\pageref{classMultiLogger}}{}
\item\contentsline{section}{\hyperlink{structNeighbourRecord}{Neighbour\+Record} }{\pageref{structNeighbourRecord}}{}
\item\contentsline{section}{\hyperlink{structNestedType}{Nested\+Type$<$ T $>$} \\*Type traits }{\pageref{structNestedType}}{}
\item\contentsline{section}{\hyperlink{structNestedType_3_01TStorage_3_01T_01_4_01_4}{Nested\+Type$<$ T\+Storage$<$ T $>$ $>$} }{\pageref{structNestedType_3_01TStorage_3_01T_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Node}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+I\+M, Index\+Type $>$\+::\+Node} }{\pageref{structSph_1_1KDTreeSingleIndexAdaptor_1_1Node}}{}
\item\contentsline{section}{\hyperlink{structNode}{Node$<$ T, d $>$} }{\pageref{structNode}}{}
\item\contentsline{section}{\hyperlink{classNoncopyable}{Noncopyable} \\*\hyperlink{classObject}{Object} with deleted copy constructor and copy operator }{\pageref{classNoncopyable}}{}
\item\contentsline{section}{\hyperlink{structNothingType}{Nothing\+Type} }{\pageref{structNothingType}}{}
\item\contentsline{section}{\hyperlink{classObject}{Object} \\*Basic object from which all types are derived }{\pageref{classObject}}{}
\item\contentsline{section}{\hyperlink{classOctree}{Octree$<$ T, d $>$} }{\pageref{classOctree}}{}
\item\contentsline{section}{\hyperlink{classOptional}{Optional$<$ T $>$} }{\pageref{classOptional}}{}
\item\contentsline{section}{\hyperlink{classOrder}{Order} }{\pageref{classOrder}}{}
\item\contentsline{section}{\hyperlink{classPointCloud}{Point\+Cloud} \\*\hyperlink{classArray}{Array} of vectors to be used in nanoflann code }{\pageref{classPointCloud}}{}
\item\contentsline{section}{\hyperlink{classPolymorphic}{Polymorphic} }{\pageref{classPolymorphic}}{}
\item\contentsline{section}{\hyperlink{classSph_1_1PooledAllocator}{Sph\+::\+Pooled\+Allocator} }{\pageref{classSph_1_1PooledAllocator}}{}
\item\contentsline{section}{\hyperlink{structMath_1_1Pow}{Math\+::\+Pow$<$ d, typename $>$} }{\pageref{structMath_1_1Pow}}{}
\item\contentsline{section}{\hyperlink{structMath_1_1Pow_3_010_01_4}{Math\+::\+Pow$<$ 0 $>$} }{\pageref{structMath_1_1Pow_3_010_01_4}}{}
\item\contentsline{section}{\hyperlink{structPowerType}{Power\+Type$<$ T, n $>$} \\*N-\/th power of a quantity }{\pageref{structPowerType}}{}
\item\contentsline{section}{\hyperlink{classProblem}{Problem$<$ T\+Model $>$} }{\pageref{classProblem}}{}
\item\contentsline{section}{\hyperlink{structProductType}{Product\+Type$<$ T1, T2 $>$} \\*Product of two quantities }{\pageref{structProductType}}{}
\item\contentsline{section}{\hyperlink{structQuotientType}{Quotient\+Type$<$ T1, T2 $>$} \\*Ratio of two quantities }{\pageref{structQuotientType}}{}
\item\contentsline{section}{\hyperlink{classSph_1_1RadiusResultSet}{Sph\+::\+Radius\+Result\+Set$<$ Distance\+Type, Index\+Type $>$} }{\pageref{classSph_1_1RadiusResultSet}}{}
\item\contentsline{section}{\hyperlink{classRandomDistribution}{Random\+Distribution} }{\pageref{classRandomDistribution}}{}
\item\contentsline{section}{\hyperlink{classRange}{Range$<$ T $>$} }{\pageref{classRange}}{}
\item\contentsline{section}{\hyperlink{classRangeAdapter}{Range\+Adapter$<$ T, T\+Step $>$} }{\pageref{classRangeAdapter}}{}
\item\contentsline{section}{\hyperlink{classRangeIterator}{Range\+Iterator$<$ T, T\+Step $>$} }{\pageref{classRangeIterator}}{}
\item\contentsline{section}{\hyperlink{structRootType}{Root\+Type$<$ T, n $>$} \\*N-\/th root of a quantity }{\pageref{structRootType}}{}
\item\contentsline{section}{\hyperlink{structSaveArraysImpl}{Save\+Arrays\+Impl$<$ T0, T\+S $>$} }{\pageref{structSaveArraysImpl}}{}
\item\contentsline{section}{\hyperlink{structSaveArraysImpl_3_01T0_01_4}{Save\+Arrays\+Impl$<$ T0 $>$} }{\pageref{structSaveArraysImpl_3_01T0_01_4}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1SearchParams}{Sph\+::\+Search\+Params} }{\pageref{structSph_1_1SearchParams}}{}
\item\contentsline{section}{\hyperlink{classSettings}{Settings$<$ T\+Enum $>$} }{\pageref{classSettings}}{}
\item\contentsline{section}{\hyperlink{classShadow}{Shadow$<$ Type $>$} }{\pageref{classShadow}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Solver}{Abstract\+::\+Solver} }{\pageref{classAbstract_1_1Solver}}{}
\item\contentsline{section}{\hyperlink{classSphericalDomain}{Spherical\+Domain} }{\pageref{classSphericalDomain}}{}
\item\contentsline{section}{\hyperlink{classStaticArray}{Static\+Array$<$ T, N $>$} }{\pageref{classStaticArray}}{}
\item\contentsline{section}{\hyperlink{classStdOut}{Std\+Out} \\*Standard output logger }{\pageref{classStdOut}}{}
\item\contentsline{section}{\hyperlink{classString}{String$<$ n $>$} \\*\hyperlink{classString}{String} with fixed size }{\pageref{classString}}{}
\item\contentsline{section}{\hyperlink{structStructNoProduct}{Struct\+No\+Product} }{\pageref{structStructNoProduct}}{}
\item\contentsline{section}{\hyperlink{structStructWithProduct}{Struct\+With\+Product} }{\pageref{structStructWithProduct}}{}
\item\contentsline{section}{\hyperlink{structStructWithQuotient}{Struct\+With\+Quotient} }{\pageref{structStructWithQuotient}}{}
\item\contentsline{section}{\hyperlink{classSymH}{SymH} }{\pageref{classSymH}}{}
\item\contentsline{section}{\hyperlink{classSymW}{SymW} }{\pageref{classSymW}}{}
\item\contentsline{section}{\hyperlink{classTimer}{Timer$<$ T\+Unit $>$} }{\pageref{classTimer}}{}
\item\contentsline{section}{\hyperlink{classAbstract_1_1Timestepping}{Abstract\+::\+Timestepping} }{\pageref{classAbstract_1_1Timestepping}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1metric__L2_1_1traits}{Sph\+::metric\+\_\+\+L2\+::traits$<$ T, Data\+Source $>$} }{\pageref{structSph_1_1metric__L2_1_1traits}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1metric__L2__Simple_1_1traits}{Sph\+::metric\+\_\+\+L2\+\_\+\+Simple\+::traits$<$ T, Data\+Source $>$} }{\pageref{structSph_1_1metric__L2__Simple_1_1traits}}{}
\item\contentsline{section}{\hyperlink{structSph_1_1metric__L1_1_1traits}{Sph\+::metric\+\_\+\+L1\+::traits$<$ T, Data\+Source $>$} }{\pageref{structSph_1_1metric__L1_1_1traits}}{}
\item\contentsline{section}{\hyperlink{classTuple}{Tuple$<$ T\+Args $>$} \\*The main class for tuple }{\pageref{classTuple}}{}
\item\contentsline{section}{\hyperlink{classTupleImpl}{Tuple\+Impl$<$ T\+Args $>$} \\*A data storage of tuple element }{\pageref{classTupleImpl}}{}
\item\contentsline{section}{\hyperlink{classTupleImpl_3_01T0_01_4}{Tuple\+Impl$<$ T0 $>$} \\*The specialization ending the recursive implementation }{\pageref{classTupleImpl_3_01T0_01_4}}{}
\item\contentsline{section}{\hyperlink{classTupleImpl_3_01T0_00_01TArgs_8_8_8_01_4}{Tuple\+Impl$<$ T0, T\+Args... $>$} }{\pageref{classTupleImpl_3_01T0_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{structTupleIterator}{Tuple\+Iterator$<$ T\+Args $>$} }{\pageref{structTupleIterator}}{}
\item\contentsline{section}{\hyperlink{structTupleSize}{Tuple\+Size$<$ T\+Tuple $>$} \\*\hyperlink{classTuple}{Tuple} size }{\pageref{structTupleSize}}{}
\item\contentsline{section}{\hyperlink{structTupleSize_3_01Tuple_3_01TArgs_8_8_8_01_4_01_4}{Tuple\+Size$<$ Tuple$<$ T\+Args... $>$ $>$} }{\pageref{structTupleSize_3_01Tuple_3_01TArgs_8_8_8_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{structTypeIndex}{Type\+Index$<$ T0, n, T1, T\+Args $>$} \\*Returns the index of type }{\pageref{structTypeIndex}}{}
\item\contentsline{section}{\hyperlink{structTypeIndex_3_01T0_00_01n_00_01T1_01_4}{Type\+Index$<$ T0, n, T1 $>$} }{\pageref{structTypeIndex_3_01T0_00_01n_00_01T1_01_4}}{}
\item\contentsline{section}{\hyperlink{structTypeSelector}{Type\+Selector$<$ n, T\+Args $>$} \\*Gets n-\/th type }{\pageref{structTypeSelector}}{}
\item\contentsline{section}{\hyperlink{structTypeSelector_3_010_00_01T0_00_01TArgs_8_8_8_01_4}{Type\+Selector$<$ 0, T0, T\+Args... $>$} }{\pageref{structTypeSelector_3_010_00_01T0_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{structTypeSelector_3_01n_00_01T0_00_01TArgs_8_8_8_01_4}{Type\+Selector$<$ n, T0, T\+Args... $>$} }{\pageref{structTypeSelector_3_01n_00_01T0_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{classUnconstructible}{Unconstructible} \\*Dummy object that cannot be constructed, usable only in templates }{\pageref{classUnconstructible}}{}
\item\contentsline{section}{\hyperlink{classUniformRng}{Uniform\+Rng} }{\pageref{classUniformRng}}{}
\item\contentsline{section}{\hyperlink{classUnion}{Union$<$ T\+Args $>$} }{\pageref{classUnion}}{}
\item\contentsline{section}{\hyperlink{classUnion_3_01T0_01_4}{Union$<$ T0 $>$} \\*Specialization for the last type }{\pageref{classUnion_3_01T0_01_4}}{}
\item\contentsline{section}{\hyperlink{classUnion_3_01T0_00_01T1_00_01TArgs_8_8_8_01_4}{Union$<$ T0, T1, T\+Args... $>$} }{\pageref{classUnion_3_01T0_00_01T1_00_01TArgs_8_8_8_01_4}}{}
\item\contentsline{section}{\hyperlink{classVariant}{Variant$<$ T\+Args $>$} \\*\hyperlink{classVariant}{Variant}, an implementation of type-\/safe union }{\pageref{classVariant}}{}
\item\contentsline{section}{\hyperlink{structVectorComponentAdapter}{Vector\+Component\+Adapter$<$ T\+Buffer $>$} \\*Wrapper for iterating over given component of vector array }{\pageref{structVectorComponentAdapter}}{}
\item\contentsline{section}{\hyperlink{classVectorOrder}{Vector\+Order} \\*\hyperlink{classOrder}{Order} in each component }{\pageref{classVectorOrder}}{}
\item\contentsline{section}{\hyperlink{classVectorPdfRng}{Vector\+Pdf\+Rng$<$ T\+Scalar\+Rng, T\+Pdf, T\+Jacobian $>$} }{\pageref{classVectorPdfRng}}{}
\item\contentsline{section}{\hyperlink{classVectorRng}{Vector\+Rng$<$ T\+Scalar\+Rng $>$} }{\pageref{classVectorRng}}{}
\end{DoxyCompactList}
