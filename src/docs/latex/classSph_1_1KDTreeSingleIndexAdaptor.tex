\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor}{}\section{Sph\+:\+:K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$ Class Template Reference}
\label{classSph_1_1KDTreeSingleIndexAdaptor}\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+I\+M, Index\+Type $>$@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+I\+M, Index\+Type $>$}}


{\ttfamily \#include $<$nanoflann.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Interval}{Interval}
\item 
struct \hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Node}{Node}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_ad953c11780c30bd9792ebef15777e4db}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_ad953c11780c30bd9792ebef15777e4db} 
typedef Distance\+::\+Element\+Type {\bfseries Element\+Type}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_adaa73c70fe7b5a7087330090107cafba}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_adaa73c70fe7b5a7087330090107cafba} 
typedef Distance\+::\+Distance\+Type {\bfseries Distance\+Type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a095fe85253e99a45f533ac830b7f69c3}{K\+D\+Tree\+Single\+Index\+Adaptor} (const int dimensionality, const Dataset\+Adaptor \&input\+Data, const \hyperlink{structSph_1_1KDTreeSingleIndexAdaptorParams}{K\+D\+Tree\+Single\+Index\+Adaptor\+Params} \&params=\hyperlink{structSph_1_1KDTreeSingleIndexAdaptorParams}{K\+D\+Tree\+Single\+Index\+Adaptor\+Params}())
\item 
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a809ad0ae1a688dd8f9870236a3157788}{$\sim$\+K\+D\+Tree\+Single\+Index\+Adaptor} ()
\item 
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a977528560c451d99bc006f3a2084b0a4}{free\+Index} ()
\item 
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a9806520fd7f6a35557d4c52043459358}{build\+Index} ()
\item 
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a48c011ca89a6a97693b7ba78e112d32c}{size} () const
\item 
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a3bdc53d8655e9e60c52fffc4fc4ce4dc}{veclen} () const
\item 
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a0f9d01c30153a3831103ba5381429e10}{used\+Memory} () const
\item 
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_adb51e3a0ffcdaf32a9153e82339070c1}{save\+Index} (F\+I\+LE $\ast$stream)
\item 
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a0509f8a856bb3c6d278a182c5e6ce654}{load\+Index} (F\+I\+LE $\ast$stream)
\end{DoxyCompactItemize}
\begin{Indent}{\bf Query methods}\par
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename R\+E\+S\+U\+L\+T\+S\+ET $>$ }\\bool \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a444955d9248884e7fcb1fb238c3b0105}{find\+Neighbors} (R\+E\+S\+U\+L\+T\+S\+ET \&result, const \hyperlink{classBasicVector}{Vector} \&vec, const \hyperlink{structSph_1_1SearchParams}{Search\+Params} \&search\+Params) const
\item 
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_ab2712a5eafbf9344143d2eadff15e802}{knn\+Search} (const Element\+Type $\ast$query\+\_\+point, const size\+\_\+t num\+\_\+closest, Index\+Type $\ast$out\+\_\+indices, Distance\+Type $\ast$out\+\_\+distances\+\_\+sq, const int=10) const
\item 
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03}{radius\+Search} (const \hyperlink{classBasicVector}{Vector} \&query\+\_\+point, const Distance\+Type \&radius, \hyperlink{classArray}{Array}$<$ \hyperlink{structNeighbourRecord}{Neighbour\+Record} $>$ \&Indices\+Dists, const \hyperlink{structSph_1_1SearchParams}{Search\+Params} \&search\+Params) const
\item 
{\footnotesize template$<$class S\+E\+A\+R\+C\+H\+\_\+\+C\+A\+L\+L\+B\+A\+CK $>$ }\\size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a536e60a78161542b81631f661635e7c5}{radius\+Search\+Custom\+Callback} (const \hyperlink{classBasicVector}{Vector} \&query\+\_\+point, S\+E\+A\+R\+C\+H\+\_\+\+C\+A\+L\+L\+B\+A\+CK \&result\+Set, const \hyperlink{structSph_1_1SearchParams}{Search\+Params} \&search\+Params=\hyperlink{structSph_1_1SearchParams}{Search\+Params}()) const
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a5bfc663e833429c4f8c3761c50112139}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a5bfc663e833429c4f8c3761c50112139} 
Distance {\bfseries distance}
\end{DoxyCompactItemize}
\subsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a2916c59e8cd4645f22923be1286609c7}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a2916c59e8cd4645f22923be1286609c7} 
typedef \hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Node}{Node} $\ast$ {\bfseries Node\+Ptr}
\item 
typedef \hyperlink{structSph_1_1array__or__vector__selector}{array\+\_\+or\+\_\+vector\+\_\+selector}$<$ D\+IM, \hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Interval}{Interval} $>$\+::container\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_aaf4a44f184e81388817dbffb5771f186}{Bounding\+Box}
\item 
typedef \hyperlink{structSph_1_1array__or__vector__selector}{array\+\_\+or\+\_\+vector\+\_\+selector}$<$ D\+IM, Distance\+Type $>$\+::container\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a662e739c535b91fc6a837595f00d28cb}{distance\+\_\+vector\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classArray}{Array}$<$ Index\+Type $>$ \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a0a716f1a65f2d3f7984e8de05abae9ad}{vind}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_aee1c62c8fb9ccf4cd1f42984f32d6f7d}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_aee1c62c8fb9ccf4cd1f42984f32d6f7d} 
size\+\_\+t {\bfseries m\+\_\+leaf\+\_\+max\+\_\+size}
\item 
const Dataset\+Adaptor \& \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a4237e355ab2fc9487e0deb5bb96ad127}{dataset}
\begin{DoxyCompactList}\small\item\em The source of our data. \end{DoxyCompactList}\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a194cf5399f404e46b10493481ee8b96c}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a194cf5399f404e46b10493481ee8b96c} 
const \hyperlink{structSph_1_1KDTreeSingleIndexAdaptorParams}{K\+D\+Tree\+Single\+Index\+Adaptor\+Params} {\bfseries index\+\_\+params}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_aa387d0a3ea9b0cff67c25acb488730a9}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_aa387d0a3ea9b0cff67c25acb488730a9} 
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_aa387d0a3ea9b0cff67c25acb488730a9}{m\+\_\+size}
\begin{DoxyCompactList}\small\item\em Number of current poins in the dataset. \end{DoxyCompactList}\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_aa6e68610be4a5763b02e36c77776543c}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_aa6e68610be4a5763b02e36c77776543c} 
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_aa6e68610be4a5763b02e36c77776543c}{m\+\_\+size\+\_\+at\+\_\+index\+\_\+build}
\begin{DoxyCompactList}\small\item\em Number of points in the dataset when the index was built. \end{DoxyCompactList}\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a251cff804024c3de6cc015ac7628b9d5}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a251cff804024c3de6cc015ac7628b9d5} 
int \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a251cff804024c3de6cc015ac7628b9d5}{dim}
\begin{DoxyCompactList}\small\item\em Dimensionality of each data point. \end{DoxyCompactList}\item 
\hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Node}{Node\+Ptr} \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_ad50d49993d446a1ab158fc75d55a7bd5}{root\+\_\+node}
\item 
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a423451ae505e1bb392be569b897c8660}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a423451ae505e1bb392be569b897c8660} 
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_aaf4a44f184e81388817dbffb5771f186}{Bounding\+Box} {\bfseries root\+\_\+bbox}
\item 
\hyperlink{classSph_1_1PooledAllocator}{Pooled\+Allocator} \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a0c3283516e497df16563c3e635ae4d29}{pool}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Distance, class Dataset\+Adaptor, int D\+IM = -\/1, typename Index\+Type = size\+\_\+t$>$\newline
class Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor$<$ Distance, Dataset\+Adaptor, D\+I\+M, Index\+Type $>$}

kd-\/tree index

Contains the k-\/d trees and other information for indexing a set of points for nearest-\/neighbor matching.

The class \char`\"{}\+Dataset\+Adaptor\char`\"{} must provide the following interface (can be non-\/virtual, inlined methods)\+:


\begin{DoxyCode}
      \textcolor{comment}{// Must return the number of data poins}
      \textcolor{keyword}{inline} \textcolor{keywordtype}{size\_t} kdtree\_get\_point\_count()\textcolor{keyword}{ const }\{ ... \}
   
      \textcolor{comment}{// [Only if using the metric\_L2\_Simple type] Must return the Euclidean (L2) distance between the}
vector \textcolor{stringliteral}{"p1[0:size-1]"} and the data point with index \textcolor{stringliteral}{"idx\_p2"} stored in the \textcolor{keyword}{class}:
      \textcolor{keyword}{inline} DistanceType kdtree\_distance(\textcolor{keyword}{const} T *p1, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} idx\_p2,\textcolor{keywordtype}{size\_t} 
      \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a48c011ca89a6a97693b7ba78e112d32c}{size})\textcolor{keyword}{ const }\{ ... \}
   
      \textcolor{comment}{// Must return the dim'th component of the idx'th point in the class:}
      \textcolor{keyword}{inline} T kdtree\_get\_pt(\textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} idx, \textcolor{keywordtype}{int} \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a251cff804024c3de6cc015ac7628b9d5}{dim})\textcolor{keyword}{ const }\{ ... \}
   
      \textcolor{comment}{// Optional bounding-box computation: return false to default to a standard bbox computation loop.}
      \textcolor{comment}{//   Return true if the BBOX was already computed by the class and returned in "bb" so it can be}
avoided to redo it again.
      \textcolor{comment}{//   Look at bb.size() to find out the expected dimensionality (e.g. 2 or 3 for point clouds)}
      \textcolor{keyword}{template} <\textcolor{keyword}{class} BBOX>
      \textcolor{keywordtype}{bool} kdtree\_get\_bbox(BBOX &bb)\textcolor{keyword}{ const}
\textcolor{keyword}{      }\{
         bb[0].low = ...; bb[0].high = ...;  \textcolor{comment}{// 0th dimension limits}
         bb[1].low = ...; bb[1].high = ...;  \textcolor{comment}{// 1st dimension limits}
         ...
         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \}
\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em Dataset\+Adaptor} & The user-\/provided adaptor (see comments above). \\
\hline
{\em Distance} & The distance metric to use\+: \hyperlink{structSph_1_1metric__L1}{metric\+\_\+\+L1}, \hyperlink{structSph_1_1metric__L2}{metric\+\_\+\+L2}, \hyperlink{structSph_1_1metric__L2__Simple}{metric\+\_\+\+L2\+\_\+\+Simple}, etc. \\
\hline
{\em D\+IM} & Dimensionality of data points (e.\+g. 3 for 3D points) \\
\hline
{\em Index\+Type} & Will be typically size\+\_\+t or int \\
\hline
\end{DoxyTemplParams}


\subsection{Member Typedef Documentation}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_aaf4a44f184e81388817dbffb5771f186}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_aaf4a44f184e81388817dbffb5771f186} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!Bounding\+Box@{Bounding\+Box}}
\index{Bounding\+Box@{Bounding\+Box}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{Bounding\+Box}{BoundingBox}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
typedef \hyperlink{structSph_1_1array__or__vector__selector}{array\+\_\+or\+\_\+vector\+\_\+selector}$<$D\+IM, \hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Interval}{Interval}$>$\+::container\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_aaf4a44f184e81388817dbffb5771f186}{Bounding\+Box}\hspace{0.3cm}{\ttfamily [protected]}}

Define \char`\"{}\+Bounding\+Box\char`\"{} as a fixed-\/size or variable-\/size container depending on \char`\"{}\+D\+I\+M\char`\"{} \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a662e739c535b91fc6a837595f00d28cb}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a662e739c535b91fc6a837595f00d28cb} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!distance\+\_\+vector\+\_\+t@{distance\+\_\+vector\+\_\+t}}
\index{distance\+\_\+vector\+\_\+t@{distance\+\_\+vector\+\_\+t}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{distance\+\_\+vector\+\_\+t}{distance\_vector\_t}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
typedef \hyperlink{structSph_1_1array__or__vector__selector}{array\+\_\+or\+\_\+vector\+\_\+selector}$<$D\+IM, Distance\+Type$>$\+::container\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a662e739c535b91fc6a837595f00d28cb}{distance\+\_\+vector\+\_\+t}\hspace{0.3cm}{\ttfamily [protected]}}

Define \char`\"{}distance\+\_\+vector\+\_\+t\char`\"{} as a fixed-\/size or variable-\/size container depending on \char`\"{}\+D\+I\+M\char`\"{} 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a095fe85253e99a45f533ac830b7f69c3}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a095fe85253e99a45f533ac830b7f69c3} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!K\+D\+Tree\+Single\+Index\+Adaptor@{K\+D\+Tree\+Single\+Index\+Adaptor}}
\index{K\+D\+Tree\+Single\+Index\+Adaptor@{K\+D\+Tree\+Single\+Index\+Adaptor}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{K\+D\+Tree\+Single\+Index\+Adaptor()}{KDTreeSingleIndexAdaptor()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{K\+D\+Tree\+Single\+Index\+Adaptor} (\begin{DoxyParamCaption}\item[{const int}]{dimensionality,  }\item[{const Dataset\+Adaptor \&}]{input\+Data,  }\item[{const \hyperlink{structSph_1_1KDTreeSingleIndexAdaptorParams}{K\+D\+Tree\+Single\+Index\+Adaptor\+Params} \&}]{params = {\ttfamily \hyperlink{structSph_1_1KDTreeSingleIndexAdaptorParams}{K\+D\+Tree\+Single\+Index\+Adaptor\+Params}()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

K\+D\+Tree constructor

Refer to docs in R\+E\+A\+D\+M\+E.\+md or online in \href{https://github.com/jlblancoc/nanoflann}{\tt https\+://github.\+com/jlblancoc/nanoflann}

The K\+D-\/\+Tree point dimension (the length of each point in the datase, e.\+g. 3 for 3D points) is determined by means of\+:
\begin{DoxyItemize}
\item The {\itshape D\+IM} template parameter if $>$0 (highest priority)
\item Otherwise, the {\itshape dimensionality} parameter of this constructor.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em input\+Data} & Dataset with the input features \\
\hline
{\em params} & Basically, the maximum leaf node size \\
\hline
\end{DoxyParams}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a809ad0ae1a688dd8f9870236a3157788}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a809ad0ae1a688dd8f9870236a3157788} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!````~K\+D\+Tree\+Single\+Index\+Adaptor@{$\sim$\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\index{````~K\+D\+Tree\+Single\+Index\+Adaptor@{$\sim$\+K\+D\+Tree\+Single\+Index\+Adaptor}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{$\sim$\+K\+D\+Tree\+Single\+Index\+Adaptor()}{~KDTreeSingleIndexAdaptor()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::$\sim$\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{K\+D\+Tree\+Single\+Index\+Adaptor} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Standard destructor 

\subsection{Member Function Documentation}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a9806520fd7f6a35557d4c52043459358}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a9806520fd7f6a35557d4c52043459358} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!build\+Index@{build\+Index}}
\index{build\+Index@{build\+Index}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{build\+Index()}{buildIndex()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::build\+Index (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Builds the index \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a444955d9248884e7fcb1fb238c3b0105}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a444955d9248884e7fcb1fb238c3b0105} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!find\+Neighbors@{find\+Neighbors}}
\index{find\+Neighbors@{find\+Neighbors}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{find\+Neighbors()}{findNeighbors()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
template$<$typename R\+E\+S\+U\+L\+T\+S\+ET $>$ \\
bool \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::find\+Neighbors (\begin{DoxyParamCaption}\item[{R\+E\+S\+U\+L\+T\+S\+ET \&}]{result,  }\item[{const \hyperlink{classBasicVector}{Vector} \&}]{vec,  }\item[{const \hyperlink{structSph_1_1SearchParams}{Search\+Params} \&}]{search\+Params }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Find set of nearest neighbors to vec\mbox{[}0\+:dim-\/1\mbox{]}. Their indices are stored inside the result object.

Params\+: result = the result object in which the indices of the nearest-\/neighbors are stored vec = the vector for which to search the nearest neighbors


\begin{DoxyTemplParams}{Template Parameters}
{\em R\+E\+S\+U\+L\+T\+S\+ET} & Should be any Result\+Set$<$\+Distance\+Type$>$ \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
True if the requested neighbors could be found. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_ab2712a5eafbf9344143d2eadff15e802}{knn\+Search}, \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03}{radius\+Search} 
\end{DoxySeeAlso}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a977528560c451d99bc006f3a2084b0a4}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a977528560c451d99bc006f3a2084b0a4} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!free\+Index@{free\+Index}}
\index{free\+Index@{free\+Index}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{free\+Index()}{freeIndex()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::free\+Index (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Frees the previously-\/built index. Automatically called within \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a9806520fd7f6a35557d4c52043459358}{build\+Index()}. \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_ab2712a5eafbf9344143d2eadff15e802}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_ab2712a5eafbf9344143d2eadff15e802} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!knn\+Search@{knn\+Search}}
\index{knn\+Search@{knn\+Search}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{knn\+Search()}{knnSearch()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::knn\+Search (\begin{DoxyParamCaption}\item[{const Element\+Type $\ast$}]{query\+\_\+point,  }\item[{const size\+\_\+t}]{num\+\_\+closest,  }\item[{Index\+Type $\ast$}]{out\+\_\+indices,  }\item[{Distance\+Type $\ast$}]{out\+\_\+distances\+\_\+sq,  }\item[{const int}]{ = {\ttfamily 10} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Find the \char`\"{}num\+\_\+closest\char`\"{} nearest neighbors to the {\itshape query\+\_\+point}\mbox{[}0\+:dim-\/1\mbox{]}. Their indices are stored inside the result object. \begin{DoxySeeAlso}{See also}
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03}{radius\+Search}, \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a444955d9248884e7fcb1fb238c3b0105}{find\+Neighbors} 
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
n\+Checks\+\_\+\+I\+G\+N\+O\+R\+ED is ignored but kept for compatibility with the original F\+L\+A\+NN interface. 
\end{DoxyNote}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a0509f8a856bb3c6d278a182c5e6ce654}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a0509f8a856bb3c6d278a182c5e6ce654} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!load\+Index@{load\+Index}}
\index{load\+Index@{load\+Index}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{load\+Index()}{loadIndex()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::load\+Index (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{stream }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Loads a previous index from a binary file. I\+M\+P\+O\+R\+T\+A\+NT N\+O\+TE\+: The set of data points is N\+OT stored in the file, so the index object must be constructed associated to the same source of data points used while building the index. See the example\+: examples/saveload\+\_\+example.\+cpp \begin{DoxySeeAlso}{See also}
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a0509f8a856bb3c6d278a182c5e6ce654}{load\+Index} 
\end{DoxySeeAlso}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!radius\+Search@{radius\+Search}}
\index{radius\+Search@{radius\+Search}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{radius\+Search()}{radiusSearch()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::radius\+Search (\begin{DoxyParamCaption}\item[{const \hyperlink{classBasicVector}{Vector} \&}]{query\+\_\+point,  }\item[{const Distance\+Type \&}]{radius,  }\item[{\hyperlink{classArray}{Array}$<$ \hyperlink{structNeighbourRecord}{Neighbour\+Record} $>$ \&}]{Indices\+Dists,  }\item[{const \hyperlink{structSph_1_1SearchParams}{Search\+Params} \&}]{search\+Params }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Find all the neighbors to {\itshape query\+\_\+point}\mbox{[}0\+:dim-\/1\mbox{]} within a maximum radius. The output is given as a vector of pairs, of which the first element is a point index and the second the corresponding distance. Previous contents of {\itshape Indices\+Dists} are cleared.

If search\+Params.\+sorted==true, the output list is sorted by ascending distances.

For a better performance, it is advisable to do a .reserve() on the vector if you have any wild guess about the number of expected matches.

\begin{DoxySeeAlso}{See also}
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_ab2712a5eafbf9344143d2eadff15e802}{knn\+Search}, \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a444955d9248884e7fcb1fb238c3b0105}{find\+Neighbors}, \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a536e60a78161542b81631f661635e7c5}{radius\+Search\+Custom\+Callback} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
The number of points within the given radius (i.\+e. indices.\+size() or dists.\+size() ) 
\end{DoxyReturn}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a536e60a78161542b81631f661635e7c5}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a536e60a78161542b81631f661635e7c5} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!radius\+Search\+Custom\+Callback@{radius\+Search\+Custom\+Callback}}
\index{radius\+Search\+Custom\+Callback@{radius\+Search\+Custom\+Callback}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{radius\+Search\+Custom\+Callback()}{radiusSearchCustomCallback()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
template$<$class S\+E\+A\+R\+C\+H\+\_\+\+C\+A\+L\+L\+B\+A\+CK $>$ \\
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::radius\+Search\+Custom\+Callback (\begin{DoxyParamCaption}\item[{const \hyperlink{classBasicVector}{Vector} \&}]{query\+\_\+point,  }\item[{S\+E\+A\+R\+C\+H\+\_\+\+C\+A\+L\+L\+B\+A\+CK \&}]{result\+Set,  }\item[{const \hyperlink{structSph_1_1SearchParams}{Search\+Params} \&}]{search\+Params = {\ttfamily \hyperlink{structSph_1_1SearchParams}{Search\+Params}()} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Just like \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03}{radius\+Search()} but with a custom callback class for each point found in the radius of the query. See the source of Radius\+Result\+Set$<$$>$ as a start point for your own classes. \begin{DoxySeeAlso}{See also}
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a1b00ad9bd5a4e2e265011ad4d2265e03}{radius\+Search} 
\end{DoxySeeAlso}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_adb51e3a0ffcdaf32a9153e82339070c1}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_adb51e3a0ffcdaf32a9153e82339070c1} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!save\+Index@{save\+Index}}
\index{save\+Index@{save\+Index}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{save\+Index()}{saveIndex()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
void \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::save\+Index (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{stream }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Stores the index in a binary file. I\+M\+P\+O\+R\+T\+A\+NT N\+O\+TE\+: The set of data points is N\+OT stored in the file, so when loading the index object it must be constructed associated to the same source of data points used while building it. See the example\+: examples/saveload\+\_\+example.\+cpp \begin{DoxySeeAlso}{See also}
\hyperlink{classSph_1_1KDTreeSingleIndexAdaptor_a0509f8a856bb3c6d278a182c5e6ce654}{load\+Index} 
\end{DoxySeeAlso}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a48c011ca89a6a97693b7ba78e112d32c}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a48c011ca89a6a97693b7ba78e112d32c} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!size@{size}}
\index{size@{size}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns number of points in dataset \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a0f9d01c30153a3831103ba5381429e10}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a0f9d01c30153a3831103ba5381429e10} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!used\+Memory@{used\+Memory}}
\index{used\+Memory@{used\+Memory}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{used\+Memory()}{usedMemory()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::used\+Memory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Computes the inde memory usage Returns\+: memory used by the index \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a3bdc53d8655e9e60c52fffc4fc4ce4dc}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a3bdc53d8655e9e60c52fffc4fc4ce4dc} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!veclen@{veclen}}
\index{veclen@{veclen}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{veclen()}{veclen()}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
size\+\_\+t \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::veclen (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the length of each point in the dataset 

\subsection{Member Data Documentation}
\hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a4237e355ab2fc9487e0deb5bb96ad127}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a4237e355ab2fc9487e0deb5bb96ad127} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!dataset@{dataset}}
\index{dataset@{dataset}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{dataset}{dataset}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
const Dataset\+Adaptor\& \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::dataset\hspace{0.3cm}{\ttfamily [protected]}}



The source of our data. 

The dataset used by this index \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a0c3283516e497df16563c3e635ae4d29}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a0c3283516e497df16563c3e635ae4d29} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!pool@{pool}}
\index{pool@{pool}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{pool}{pool}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
\hyperlink{classSph_1_1PooledAllocator}{Pooled\+Allocator} \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::pool\hspace{0.3cm}{\ttfamily [protected]}}

Pooled memory allocator.

Using a pooled memory allocator is more efficient than allocating memory directly when there is a large number small of memory allocations. \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_ad50d49993d446a1ab158fc75d55a7bd5}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_ad50d49993d446a1ab158fc75d55a7bd5} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!root\+\_\+node@{root\+\_\+node}}
\index{root\+\_\+node@{root\+\_\+node}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{root\+\_\+node}{root\_node}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
\hyperlink{structSph_1_1KDTreeSingleIndexAdaptor_1_1Node}{Node\+Ptr} \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::root\+\_\+node\hspace{0.3cm}{\ttfamily [protected]}}

The K\+D-\/tree used to find neighbours \hypertarget{classSph_1_1KDTreeSingleIndexAdaptor_a0a716f1a65f2d3f7984e8de05abae9ad}{}\label{classSph_1_1KDTreeSingleIndexAdaptor_a0a716f1a65f2d3f7984e8de05abae9ad} 
\index{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}!vind@{vind}}
\index{vind@{vind}!Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor@{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}}
\subsubsection{\texorpdfstring{vind}{vind}}
{\footnotesize\ttfamily template$<$typename Distance , class Dataset\+Adaptor , int D\+IM = -\/1, typename Index\+Type  = size\+\_\+t$>$ \\
\hyperlink{classArray}{Array}$<$Index\+Type$>$ \hyperlink{classSph_1_1KDTreeSingleIndexAdaptor}{Sph\+::\+K\+D\+Tree\+Single\+Index\+Adaptor}$<$ Distance, Dataset\+Adaptor, D\+IM, Index\+Type $>$\+::vind\hspace{0.3cm}{\ttfamily [protected]}}

\hyperlink{classArray}{Array} of indices to vectors in the dataset. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/pavel/projects/astro/sph2/src/tree/nanoflann.\+h\end{DoxyCompactItemize}
